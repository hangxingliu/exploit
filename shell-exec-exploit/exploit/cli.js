#!/usr/bin/env node

//@ts-check
const help = () => {
	console.log([
		'',
		'  Usage: ./cli.js [action]',
		'',
		'  Actions:',
		'    help: show this help',
		'    init: init workspace environment on server',
		'    destroy: destroy workspace environment on server',
		'    shell|repl: simple repl, read command and execute on server',
		'    exec [file]: read file content and execute on server',
		'    upload [remoteLocation] [file1] [file2] ...: upload file content to server',
		'',
		'  Examples:',
		'    ./cli.js upload /tmp/exp/ assets/cve-2017-1000112.c',
		''
	].join('\n'));
	process.exit(0);
};

const DOWNLOAD_DIR = 'download';
const BASE_PATH = '/';
const ALIAS = {
	'll': 'ls -alF',
	'la': 'ls -A'
};

const ACTION = ['init', 'shell', 'repl', 'exec', 'upload', 'destroy'];
const CONFIG_FILE = 'config.js';

let fs = require('fs'),
	path = require('path'),
	url = require('url');
require('colors');

if (!fs.existsSync(path.join(__dirname, CONFIG_FILE))) { 
	console.error(`\n  error: please create ${CONFIG_FILE}!\n`);
	process.exit(1);
}	

let core = require('./libs/core');
let hostname = url.parse(core.config.uri).hostname;
let action = process.argv[2];
let replPath = '', replUser = 'unknown';
let replDirectoryStack = []; 
let repl = null;

if (!action || action == 'help' || ACTION.indexOf(action) < 0)	
	help();

main();

function main() {
	switch (action) {
		case 'init':
			console.log(`Init workspace on ${hostname} ...`);
			core.installWorkspaceOnServer();
			return;	
		case 'destroy':
			console.log(`Destroy workspace on ${hostname} ...`);
			core.destroyWorkspace();
			return;
		case 'shell':
		case 'repl':
			console.log(`Launching REPL on ${hostname} ...`);
			console.log(`  asking user name ...`.dim.grey);
			// random border
			let s1 = Math.random().toFixed(2).replace('.', 'd'),
				s2 = (Math.random() + 1).toFixed(3).replace('.', 'd');
			core.shell(`echo "${s1}$(whoami)${s1}";echo "${s2}$(pwd)${s2}";`, (result, code) => {
				replUser = (String(result).match(new RegExp(s1 + '(.+)' + s1)) || ['', 'unknown'])[1];
				replPath = (String(result).match(new RegExp(s2 + '(.+)' + s2)) || ['', BASE_PATH])[1];

				console.log([
					`  repl launched!`,
					``,
					`  addon commands:`,
					`    .exec <file>: execute a executable remote file`,
					`    .download <file>: download a remote file`,
					`    .view <file>: view a remote file (encoding safe)`,
					`    .clear|.cls: clear screen`,
					`    .exit: exit repl`
				].map(v => v.dim.grey).join('\n'));

				repl = require('repl').start({ prompt: getReplPrompt(), eval: replEval });
				repl.defineCommand('cls', { help: 'clear screen', action: clearScreen });
				repl.defineCommand('clear', { help: 'clear screen', action: clearScreen });
				repl.defineCommand('exec', { help: 'execute a remote file', action: execRemoteFile})
				repl.defineCommand('download', {
					help: 'download a remote file',
					action(f) { downloadOrViewRemoteFile(false, f) }
				});
				repl.defineCommand('view', {
					help: 'view a remote file (encoding safe)',
					action(f) { downloadOrViewRemoteFile(true, f) }
				});
			});
			return;
		case 'upload':
			let remotePath = (process.argv[3] || '').trim();
			let files = process.argv.slice(4);
			if (!remotePath) { console.error(`\n  error: no "remoteLocation"`.red); process.exit(10); }
			if (!files.length) { console.error(`\n  error: no "remoteLocation"`.red); process.exit(11); }
			console.log('\nupload files:' + files.map((f, i) => (i % 5 == 0 ? '\n\t' : '\t') + f).join(''));
			console.log('\nremote folder: ' + remotePath);
			console.log('start uploading...');
			return startUpload(files, remotePath);
	}
}

//============== upload ==================
/** @param {string[]} _files */
function startUpload(_files, uploadTo) { 
	let i = 0;
	let files = _files.map(f => {
		let bname = path.basename(f);
		return [f, bname, path.join(uploadTo, bname)];
	});
	core.setDisplayStatusCode(false);
	upload();
	function upload() {
		if (!core.getRequestQueue().length) {
			if (i >= files.length)
				return console.log('success: all files uploaded');
			let [local, name, remote] = files[i++];
			let stat = fs.statSync(local);
			if (stat.isFile()) {
				// console.log(local, name, remote)
				core.shell(fs.readFileSync(local), (bd, res) => {
					console.log(`${res}: uploaded ${local} => ${remote} (${stat.size})`);
				}, remote, false);
			} else {
				console.error(`error: ${local} is not a file!`.red);
			}
		}
		setTimeout(upload, 10);
	}
}
//============== download ================
function downloadOrViewRemoteFile(isViewing, _file) { 
	let file = String(_file || '').trim();
	if (!file) {
		console.error(`error: no "remote file" given! (usage: .download <file>)`.red);
		repl.displayPrompt();
		return;
	}
	let random = Math.random().toFixed(5).replace('.', ':');
	let command =
		`echo "${random}";` +
		`LC_ALL=C stat -c '%F' ${file};` +
		`echo "${random}";` +
		`base64 ${file};` +
		`echo "${random}";`;
	
	let localFile = path.basename(file),
		{ ext, name } = path.parse(localFile),
		i = 1;
	
	if (!isViewing) {
		if (!fs.existsSync(DOWNLOAD_DIR))
			fs.mkdirSync(DOWNLOAD_DIR);
	
		while (fs.existsSync(path.join(DOWNLOAD_DIR, localFile)))
			localFile = name + `.${i++}` + ext;
		console.log(`downloading ${file.bold} to ${DOWNLOAD_DIR}/${localFile.bold} ...`);
	} else {
		console.log(`loading ${file.bold} ...`);
	}
	
	replEval(command, null, null, (_, statusCode, result) => {
		let mt = result.match(new RegExp(random + '([\\s\\S]+)' + random + '([\\s\\S]+)' + random));
		if (!mt) {
			console.error(`error: could not get file content from response!`.red);
			return repl.displayPrompt();
		}
		let type = (mt[1] || '').trim(), base64 = mt[2];
		if (type.indexOf('file') > 0) {
			if (isViewing) {
				console.log('Content:'.bold);
				console.log(new Buffer(base64, 'base64').toString());
			} else {
				try {
					fs.writeFileSync(path.join(DOWNLOAD_DIR, localFile),
						new Buffer(base64, 'base64'));
					console.log('success!');
				} catch (ex) {
					console.error(`error: write to local file failed!`.red);
				}
			}	
		} else {
			console.error(`error: ${file} is not a file! (${type})`.red);
		}
		repl.displayPrompt();
	}, true);
}
//============== repl ==================
function getReplPrompt() {
	return `${replUser}@${hostname}`.green.bold + `:${(replPath||'').blue.bold}` + ` $ `
}
function clearScreen() { 
	console.log('\x1B[2J\x1B[0f');
	console.log('screen be cleared!');
	repl.displayPrompt();
}
function execRemoteFile(file) { 
	file = (file || '').trim();
	if (!file) {
		console.error(`error: no "remote file" given! (usage: .exec <file>)`.red);
		repl.displayPrompt();
		return;
	}
	replEval(file, null, null, (_, statusCode) => {
		console.log(`execute remote file success! (${statusCode})`)
		repl.displayPrompt();
	});
}
function replEval(cmd, context, filename, callback, dontDisplay = false) {
	let isCd = false, isPushd = false, isPopd = false, cdTo = '/';
	let random = Math.random().toFixed(3).replace('.', 'z');

	cmd = cmd.trim();

	if (cmd == 'exit') process.exit(0);
	if (cmd.match(/^(cd|pushd)\s/)) {
		isCd = cmd.match(/^cd/);
		isPushd = cmd.match(/^pushd/);
		cdTo = cmd.replace(/^(cd|pushd)/, '').trim();
		
		if (!path.isAbsolute(cdTo))
			cdTo = path.join(replPath || BASE_PATH, cdTo);
		
		cmd = `echo "${random}$(stat -c '%A user: %U group: %G~%n' ${cdTo})${random}"`;
	} else if (cmd.match(/^popd\s*/)) {
		isPopd = true;
		cdTo = replDirectoryStack.pop();
		if (!cdTo)
			return callback(null, `popd: directory stack empty`);
		console.log(cdTo)
		cmd = `echo "${random}$(stat -c '%A user: %U group: %G~%n' ${cdTo})${random}"`;
	}

	//replace alias
	for (let key of Object.keys(ALIAS)) { 
		if (cmd.startsWith(key)) {
			cmd = cmd.replace(key, ALIAS[key]) + ' ';
			break;
		}
	}

	//set repl path
	if (replPath) cmd = `cd ${replPath};` + cmd;
		
	// console.log(`executing ${JSON.stringify(cmd)} ...`.dim.grey);
	core.shell(cmd, (_result, statusCode) => {
		let result = String(_result).trim();
		if (isCd || isPushd || isPopd)
			return handlerCdResponse(callback, result, statusCode);
		
		dontDisplay || console.log(result);
		callback(null, statusCode, dontDisplay ? result : void 0);
	}, null, true);


	function handlerCdResponse(callback, _result = '', statusCode = 200) { 
		let prefix = isPushd ? 'pushd' : (isPopd ? 'popd' : 'cd');
		let result = _result.match(new RegExp(random + '(.+)' + random));
		if (!result || !result[1])
			return console.error(`${prefix} to ${cdTo} failed!`.red), callback(null, statusCode);
		
		let c = result[1].indexOf('~');
		let access = result[1].slice(0, c), path = result[1].slice(c + 1);
		if (c < 0 || !access || !path)
			return console.error(`${prefix} to ${cdTo} failed! (${result[1]})`.red), callback(null, statusCode);
		
		console.log(`${prefix} to ${path.bold} (${access})`);
		if (isPushd) {
			replDirectoryStack.push(replPath);
			console.log('  directory stack: '.dim + replDirectoryStack.map(v => v).reverse().join('  '));
		}
		replPath = path;
		repl.setPrompt(getReplPrompt());
		return callback(null, statusCode);
	}
}
